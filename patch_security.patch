diff --git a/mediaResources/icudtl.dat b/mediaResources/icudtl.dat
new file mode 100644
index 0000000..b3e6a70
Binary files /dev/null and b/mediaResources/icudtl.dat differ
diff --git a/mediaResources/test.txt b/mediaResources/test.txt
new file mode 100644
index 0000000..4429471
--- /dev/null
+++ b/mediaResources/test.txt
@@ -0,0 +1 @@
+Hello World!
diff --git a/pom.xml b/pom.xml
index b74dfe1..52076b3 100755
--- a/pom.xml
+++ b/pom.xml
@@ -85,6 +85,12 @@
 
     <dependencies>
         <dependency>
+            <!-- jsoup HTML parser library @ https://jsoup.org/ -->
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>1.10.3</version>
+        </dependency>
+        <dependency>
             <groupId>io.dropwizard.metrics</groupId>
             <artifactId>metrics-core</artifactId>
         </dependency>
diff --git a/src/main/java/com/acme/AcmeApp.java b/src/main/java/com/acme/AcmeApp.java
index bf7213a..6a1e73d 100755
--- a/src/main/java/com/acme/AcmeApp.java
+++ b/src/main/java/com/acme/AcmeApp.java
@@ -71,6 +71,5 @@ public class AcmeApp {
 			env.getProperty("server.port"),
 			InetAddress.getLocalHost().getHostAddress(),
 			env.getProperty("server.port"));
-
 	}
 }
diff --git a/src/main/java/com/acme/domain/ACMEPass.java b/src/main/java/com/acme/domain/ACMEPass.java
index a8317f6..5470e9c 100755
--- a/src/main/java/com/acme/domain/ACMEPass.java
+++ b/src/main/java/com/acme/domain/ACMEPass.java
@@ -19,6 +19,10 @@ import javax.crypto.BadPaddingException;
 import javax.crypto.IllegalBlockSizeException;
 import javax.xml.bind.DatatypeConverter;
 
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
+
 /**
  * A ACMEPass.
  */
@@ -29,10 +33,6 @@ public class ACMEPass extends AbstractDatedEntity implements Serializable {
 
 	private static final long serialVersionUID = 1L;
 
-	private static final Key k = new SecretKeySpec(new byte[]{(byte) 0x21, (byte) 0x9e, (byte) 0x48, (byte) 0xd7,
-		(byte) 0x50, (byte) 0x49, (byte) 0x1d, (byte) 0x8c, (byte) 0x1e, (byte) 0x37,
-		(byte) 0x28, (byte) 0xaf, (byte) 0xcc, (byte) 0xfd, (byte) 0x9e, (byte) 0xc7}, "AES");
-
 	@Id
 	@GeneratedValue(strategy = GenerationType.AUTO)
 	private Long id;
@@ -91,6 +91,7 @@ public class ACMEPass extends AbstractDatedEntity implements Serializable {
 	public String getPassword() {
 		if (password != null) {
 			try {
+				Key k = this.getKey();
 				Cipher c = Cipher.getInstance("AES");
 				c.init(Cipher.DECRYPT_MODE, k);
 				return new String(c.doFinal(DatatypeConverter.parseBase64Binary(password)));
@@ -109,6 +110,7 @@ public class ACMEPass extends AbstractDatedEntity implements Serializable {
 
 	public void setPassword(String password) {
 		try {
+			Key k = this.getKey();
 			Cipher c = Cipher.getInstance("AES");
 			c.init(Cipher.ENCRYPT_MODE, k);
 			this.password = DatatypeConverter.printBase64Binary(c.doFinal(password.getBytes()));
@@ -162,4 +164,41 @@ public class ACMEPass extends AbstractDatedEntity implements Serializable {
 			+ ", lastModifiedDate='" + lastModifiedDate + "'"
 			+ '}';
 	}
+	
+	private Key getKey(){
+		String name = "encrypt.properties";
+		Properties props = new Properties();
+
+		InputStream inputStream = ACMEPass.class.getClassLoader().getResourceAsStream(name);
+		if (inputStream != null) {
+			try {
+				props.load(inputStream);
+			} catch (IOException e) {
+				System.out.println("Error occurred.");
+			} finally {
+				try {
+					inputStream.close();
+				} catch (IOException e) {
+					System.out.println("Error occurred.");
+				}
+			}
+		} else {
+			System.out.println("Could not find " + name);
+		}
+
+		String key = props.getProperty("key");
+		byte[] byteArray = hexStringToByteArray(key);
+		
+		return new SecretKeySpec(byteArray, "AES");
+	}
+	
+	private static byte[] hexStringToByteArray(String s) {
+	    int len = s.length();
+	    byte[] data = new byte[len / 2];
+	    for (int i = 0; i < len; i += 2) {
+	        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+	                             + Character.digit(s.charAt(i+1), 16));
+	    }
+	    return data;
+	}
 }
diff --git a/src/main/java/com/acme/service/ACMEPassService.java b/src/main/java/com/acme/service/ACMEPassService.java
index e63ba6e..ea34e57 100755
--- a/src/main/java/com/acme/service/ACMEPassService.java
+++ b/src/main/java/com/acme/service/ACMEPassService.java
@@ -45,6 +45,9 @@ public class ACMEPassService {
 			if (acmePass == null) {
 				return null;
 			}
+			if (!acmePass.getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+				return null;
+			}
 		} else {
 			acmePass = new ACMEPass();
 			acmePass.setUser(userService.getCurrentUser());
@@ -78,7 +81,12 @@ public class ACMEPassService {
 	@Transactional(readOnly = true)
 	public ACMEPassDTO findOne(Long id) {
 		log.debug("Request to get ACMEPass : {}", id);
-		return new ACMEPassDTO(acmePassRepository.findOne(id));
+		ACMEPass acmePass = acmePassRepository.findOne(id);
+		if (acmePass.getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+			return new ACMEPassDTO(acmePass);
+		} else {
+			throw new RuntimeException("You are not allowed to access this ACMEPass.");
+		}
 	}
 
 	/**
diff --git a/src/main/java/com/acme/service/ACMEPassService.java.orig b/src/main/java/com/acme/service/ACMEPassService.java.orig
new file mode 100755
index 0000000..8de0f35
--- /dev/null
+++ b/src/main/java/com/acme/service/ACMEPassService.java.orig
@@ -0,0 +1,114 @@
+package com.acme.service;
+
+import com.acme.domain.ACMEPass;
+import com.acme.repository.ACMEPassRepository;
+import com.acme.security.SecurityUtils;
+import com.acme.service.dto.ACMEPassDTO;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.transaction.annotation.Transactional;
+import org.springframework.stereotype.Service;
+
+import javax.inject.Inject;
+
+/**
+ * Service Implementation for managing ACMEPass.
+ */
+@Service
+@Transactional
+public class ACMEPassService {
+
+	private final Logger log = LoggerFactory.getLogger(ACMEPassService.class);
+
+	@Inject
+	private ACMEPassRepository acmePassRepository;
+
+	@Inject
+	private UserService userService;
+
+	/**
+	 * Save a acmePass.
+	 *
+	 * @param dto the entity to save
+	 * @return the persisted entity
+	 */
+	public ACMEPassDTO save(ACMEPassDTO dto) {
+		log.debug("Request to save ACMEPass : {}", dto);
+
+		ACMEPass acmePass;
+
+		if (dto.getId() != null) {
+			acmePass = acmePassRepository.findOne(dto.getId());
+
+			if (acmePass == null) {
+				return null;
+			}
+			if (!acmePass.getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+				return null;
+			}
+		} else {
+			acmePass = new ACMEPass();
+			acmePass.setUser(userService.getCurrentUser());
+		}
+
+		acmePass.site(dto.getSite())
+			.login(dto.getLogin())
+			.password(dto.getPassword());
+
+		return new ACMEPassDTO(acmePassRepository.save(acmePass));
+	}
+
+	/**
+	 * Get all the acmePasses of current user.
+	 *
+	 * @param pageable the pagination information
+	 * @return the list of entities
+	 */
+	@Transactional(readOnly = true)
+	public Page<ACMEPassDTO> findAllOfCurrentUser(Pageable pageable) {
+		log.debug("Request to get all ACMEPasses of current user");
+		return acmePassRepository.findByUserIsCurrentUser(pageable).map(ACMEPassDTO::new);
+	}
+
+	/**
+	 * Get one acmePass by id.
+	 *
+	 * @param id the id of the entity
+	 * @return the entity
+	 */
+	@Transactional(readOnly = true)
+	public ACMEPassDTO findOne(Long id) {
+		log.debug("Request to get ACMEPass : {}", id);
+<<<<<<< HEAD
+		ACMEPass password = acmePassRepository.findOne(id);
+		if (password.getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+			return new ACMEPassDTO(password);
+		} else {
+			return null;
+=======
+		ACMEPass acmePass = acmePassRepository.findOne(id);
+		if (acmePass.getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+			return new ACMEPassDTO(acmePass);
+		} else {
+			throw new RuntimeException("You are not allowed to access this ACMEPass.");
+>>>>>>> f18425ca6b86a1e65b809d355354f439f05c0163
+		}
+	}
+
+	/**
+	 * Delete the acmePass by id.
+	 *
+	 * @param id the id of the entity
+	 */
+	public void delete(Long id) {
+		log.debug("Request to delete ACMEPass : {}", id);
+
+		if (acmePassRepository.findOne(id).getUser().getEmail().equals(SecurityUtils.getCurrentUser())) {
+            acmePassRepository.delete(id);
+        } else {
+			throw new RuntimeException("You must be the user who created the password in order to delete the password.");
+		}
+	}
+}
diff --git a/src/main/java/com/acme/service/MediaFileService.java b/src/main/java/com/acme/service/MediaFileService.java
index 9f1a867..facf841 100755
--- a/src/main/java/com/acme/service/MediaFileService.java
+++ b/src/main/java/com/acme/service/MediaFileService.java
@@ -2,14 +2,16 @@ package com.acme.service;
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.List;
-import java.util.logging.Level;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Service;
 import org.springframework.web.multipart.MultipartFile;
 
+import javax.validation.Path;
+
 @Service
 public class MediaFileService {
 
@@ -22,8 +24,16 @@ public class MediaFileService {
 	}
 
 	public File getMediaFile(String fileName) {
+		System.out.println("I am trying to access filename: " + fileName);
 		File file = new File(MEDIA_FOLDER + fileName);
 
+		java.nio.file.Path mediaPath = Paths.get(MEDIA_FOLDER).normalize().toAbsolutePath();
+		java.nio.file.Path filePath = Paths.get(file.getAbsolutePath()).normalize().toAbsolutePath();
+
+		if (!filePath.startsWith(mediaPath) || filePath.compareTo(mediaPath) == 0) {
+			return null;
+		}
+
 		if (file.exists() && file.canRead() && file.isFile()) {
 			return file;
 		}
diff --git a/src/main/java/com/acme/web/rest/BlogPostResource.java b/src/main/java/com/acme/web/rest/BlogPostResource.java
index e20f113..b6f4269 100755
--- a/src/main/java/com/acme/web/rest/BlogPostResource.java
+++ b/src/main/java/com/acme/web/rest/BlogPostResource.java
@@ -10,6 +10,8 @@ import com.acme.web.rest.util.HeaderUtil;
 import com.acme.web.rest.util.PaginationUtil;
 
 import io.swagger.annotations.ApiParam;
+import org.jsoup.Jsoup;
+import org.jsoup.safety.Whitelist;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.data.domain.Page;
@@ -58,7 +60,7 @@ public class BlogPostResource {
 		if (blogPost.getId() != null) {
 			return ResponseEntity.badRequest().headers(HeaderUtil.createFailureAlert("blogPost", "idexists", "A new blogPost cannot already have an ID")).body(null);
 		}
-
+		blogPost.setContent(Jsoup.clean(blogPost.getContent(), Whitelist.none()));
 		BlogPost result = blogPostRepository.save(blogPost);
 		return ResponseEntity.created(new URI("/api/blog-posts/" + result.getId()))
 			.headers(HeaderUtil.createEntityCreationAlert("blogPost", result.getId().toString()))
@@ -82,6 +84,7 @@ public class BlogPostResource {
 		if (blogPost.getId() == null) {
 			return createBlogPost(blogPost);
 		}
+		blogPost.setContent(Jsoup.clean(blogPost.getContent(), Whitelist.none()));
 		BlogPost result = blogPostRepository.save(blogPost);
 		return ResponseEntity.ok()
 			.headers(HeaderUtil.createEntityUpdateAlert("blogPost", blogPost.getId().toString()))
diff --git a/src/main/java/com/acme/web/rest/CommentResource.java b/src/main/java/com/acme/web/rest/CommentResource.java
index 91970d1..826baee 100755
--- a/src/main/java/com/acme/web/rest/CommentResource.java
+++ b/src/main/java/com/acme/web/rest/CommentResource.java
@@ -7,6 +7,8 @@ import com.acme.repository.CommentRepository;
 import com.acme.web.rest.util.HeaderUtil;
 import io.swagger.annotations.ApiParam;
 
+import org.jsoup.Jsoup;
+import org.jsoup.safety.Whitelist;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.http.ResponseEntity;
@@ -62,7 +64,7 @@ public class CommentResource {
 
 	private String sanitize(String comment) {
 		StringBuilder sb = new StringBuilder();
-
+		comment = Jsoup.clean(comment, Whitelist.none());
 		Pattern pattern = Pattern.compile("(.*?)\\[(b|i|url)\\](.*?)\\[\\/\\2\\]((.|\\n)*)");
 
 		String unsanitized = comment;
diff --git a/src/main/resources/encrypt.properties b/src/main/resources/encrypt.properties
new file mode 100644
index 0000000..9f41c0c
--- /dev/null
+++ b/src/main/resources/encrypt.properties
@@ -0,0 +1 @@
+key = 219e48d750491d8c1e3728afccfd9ec7
\ No newline at end of file
